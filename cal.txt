describe('getAllData', () => {
    it('should fetch all schedules and process them', () => {
        mockScheduleApiService.getAllSchedules.mockReturnValue(of([mockSchedule]));
        
        component.getAllData();
        
        expect(component.isLoading).toBe(true);
        expect(mockScheduleApiService.getAllSchedules).toHaveBeenCalled();
        expect(mockScheduleApiService.setSchedule).toHaveBeenCalledWith([]);
        // Verify isLoading is set to false after completion
        setTimeout(() => {
            expect(component.isLoading).toBe(false);
            expect(component.dataCards).toEqual([mockDataCard]);
        });
    });

    it('should handle error when fetching schedules', () => {
        mockScheduleApiService.getAllSchedules.mockReturnValue(throwError(() => new Error('Error')));
        
        component.getAllData();
        
        expect(component.isLoading).toBe(true);
        setTimeout(() => {
            expect(component.isLoading).toBe(false);
        });
    });
});


describe('isAdminUser', () => {
    it('should return true when user is admin', () => {
        mockAppAuthService.isAdminUser.mockReturnValue(true);
        expect(component.isAdminUser()).toBe(true);
    });

    it('should return false when user is not admin', () => {
        mockAppAuthService.isAdminUser.mockReturnValue(false);
        expect(component.isAdminUser()).toBe(false);
    });
});


describe('onClickFilter', () => {
    it('should open filter dialog and handle submit event', () => {
        const mockDialogRef = { componentInstance: { submitEvent: new Subject() } };
        mockDialog.open.mockReturnValue(mockDialogRef as any);
        
        component.onClickFilter();
        
        expect(mockDialog.open).toHaveBeenCalled();
        
        // Simulate submit event
        mockDialogRef.componentInstance.submitEvent.next({
            eventType: 'submit',
            elements: [
                { label: 'Dashboard', selectedValue: mockSchedule },
                { label: 'Year', selectedValue: ['2024'] }
            ]
        });
        
        expect(component.selectedYear).toEqual(['2024']);
        expect(component.selectedAssetScheduleTitle).toBe('Test Schedule');
    });

    it('should handle groupDropdown event', () => {
        const mockDialogRef = { componentInstance: { submitEvent: new Subject() } };
        mockDialog.open.mockReturnValue(mockDialogRef as any);
        
        component.onClickFilter();
        
        // Simulate groupDropdown event
        mockDialogRef.componentInstance.submitEvent.next({
            eventType: 'groupDropdown',
            elements: [
                { label: 'Dashboard', selectedValue: mockSchedule }
            ]
        });
        
        expect(component.setFilterYearElement).toHaveBeenCalled();
    });
});


describe('createAddNewAssetSchedule', () => {
    it('should fetch assets and populate dropdown', () => {
        const mockAssets = [{ buno: 'B001' }, { buno: 'B002' }];
        mockAssetScheduleApiService.getAllAssets.mockReturnValue(of(mockAssets));
        
        component.createAddNewAssetSchedule();
        
        expect(mockAssetScheduleApiService.getAllAssets).toHaveBeenCalled();
        expect(mockAssetScheduleApiService.setAssetIds).toHaveBeenCalledWith(mockAssets);
    });
});



describe('onClickFilter', () => {
    it('should open filter dialog and handle submit event', () => {
        // Create a proper mock dialog ref with componentInstance
        const mockDialogRef = {
            componentInstance: {
                submitEvent: new Subject<ModalSubmitEvent>()
            },
            afterClosed: () => of(null) // Add afterClosed method
        };
        
        // Mock the dialog.open method to return our mock dialog ref
        mockDialog.open.mockReturnValue(mockDialogRef as any);
        
        // Initialize component data needed for the test
        component.filterModalData = {
            elements: [
                { label: 'Dashboard', selectedValue: mockSchedule },
                { label: 'Year', selectedValue: ['2024'] }
            ]
        };
        
        component.onClickFilter();
        
        expect(mockDialog.open).toHaveBeenCalledWith(MaModalComponent, {
            data: component.filterModalData
        });
        
        // Simulate submit event
        const submitEvent: ModalSubmitEvent = {
            eventType: 'submit',
            elements: [
                { label: 'Dashboard', selectedValue: mockSchedule },
                { label: 'Year', selectedValue: ['2024'] }
            ]
        };
        mockDialogRef.componentInstance.submitEvent.next(submitEvent);
        
        expect(component.selectedYear).toEqual(['2024']);
        expect(component.selectedAssetScheduleTitle).toBe('Test Schedule');
    });

    it('should handle groupDropdown event', () => {
        const mockDialogRef = {
            componentInstance: {
                submitEvent: new Subject<ModalSubmitEvent>()
            },
            afterClosed: () => of(null)
        };
        mockDialog.open.mockReturnValue(mockDialogRef as any);
        
        component.filterModalData = {
            elements: [
                { label: 'Dashboard', selectedValue: mockSchedule }
            ]
        };
        
        component.onClickFilter();
        
        // Simulate groupDropdown event
        const groupDropdownEvent: ModalSubmitEvent = {
            eventType: 'groupDropdown',
            elements: [
                { label: 'Dashboard', selectedValue: mockSchedule }
            ]
        };
        mockDialogRef.componentInstance.submitEvent.next(groupDropdownEvent);
        
        // Verify year filter element was updated
        const yearElement = component.filterModalData.elements.find(el => el.label === 'Year');
        expect(yearElement).toBeDefined();
    });
});
